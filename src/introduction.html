<!DOCTYPE html>
<html class="writer-html5" lang="English" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; qoqo-qryd 0.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Executing quantum programs" href="execution.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> qoqo-qryd
          </a>
              <div class="version">
                0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#low-level-quantum-circuits">Low level: quantum circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="#high-level-quantum-programs">High-level: quantum programs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-quantumprogram-returning-unprocessed-measurements">A QuantumProgram returning unprocessed measurements</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="execution.html">Executing quantum programs</a></li>
<li class="toctree-l1"><a class="reference internal" href="qrydspecifics.html">QRyd devices and operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">qoqo-qryd examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="qoqo_qryd_api.html">qoqo-qryd API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">qoqo-qryd</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/src/introduction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h1>
<p>The qoqo-qryd package is designed to enable the excution of quantum algorithms implemented in <a class="reference external" href="https://github.com/HQSquantumsimulations/qoqo">qoqo</a> on QRydDemo hardware.</p>
<section id="low-level-quantum-circuits">
<h2>Low level: quantum circuits<a class="headerlink" href="#low-level-quantum-circuits" title="Permalink to this headline"></a></h2>
<p>Qoqo is a circuit based quantum computing toolkit. Like many other quantum computing toolkits it can be used to construct quantum circuits sequences of quantum operations that are to be executed on a quantum computer.</p>
<p>Examples for quantum operations are the controlled NOT (CNOT) operation on two qubits and the Hadamard gate on a sinlge qubit.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">ops</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># Initializing first qubit in superposition of |0&gt; and |1&gt;</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Entangling qubits 0 and 1 with CNOT</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>To extract information from a quantum computer results must be measured.
For measurements qoqo defines classical registers in the quantum circuits.
The classical measurement results will be written to the classical registers.
The definition of classical registers is similar to a variable declaration in normal programs.
The measurement of a qubit (on hardware) is always a projective measurement in the <code class="docutils literal notranslate"><span class="pre">Z</span></code>-basis yielding <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">ops</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># Defining a bit readout with name &quot;ro&quot; containing 2 bits</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Initializing first qubit in superposition of |0&gt; and |1&gt;</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Entangling qubits 0 and 1 with CNOT</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">CNOT</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Measuring all qubits and writing the results into register &#39;ro&#39;</span>
<span class="c1"># Repeating the circuit 100 times to create 100 projective measurements</span>
<span class="n">circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro&quot;</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="high-level-quantum-programs">
<h2>High-level: quantum programs<a class="headerlink" href="#high-level-quantum-programs" title="Permalink to this headline"></a></h2>
<p>On a more abstract level a quantum program can be defined as a program that can be executed on a quantum computer after receiving a list of classical parameters and returns a list of classical results.</p>
<p>Qoqo provides the QuantumProgram class for this purpose and a QuantumProgram is the preferred way to communicate between different programs (for example with hardware or simulators) and to save quantum programs with the qoqo toolkit.</p>
<p>For many applications the measurement results of several circuits need to be combined to extract the required information from a quantum state prepared by the quantum operations in a quantum circuit.
The combination of the results of each quantum circuit happens in a classical measurement post-processing.</p>
<p>A qoqo measurement combines one <code class="docutils literal notranslate"><span class="pre">constant_circuit</span></code> that is always executed first, a list of <code class="docutils literal notranslate"><span class="pre">circuits</span></code> that are executed after the constant circuit and a <code class="docutils literal notranslate"><span class="pre">measurement_input</span></code> that encodes the classical post-processing.</p>
<p>As an example take the measurement of a Hamiltonian <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">=</span> <span class="pre">0.1</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">0.2</span> <span class="pre">*</span> <span class="pre">Z</span></code> where <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Z</span></code> are Pauli operators. We want to measure <code class="docutils literal notranslate"><span class="pre">H</span></code> with respect to a state <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span> <span class="pre">=</span> <span class="pre">(|0&gt;</span> <span class="pre">+</span> <span class="pre">|1&gt;)/sqrt(2)</span></code>.
We will use a Hadamard gate in the <code class="docutils literal notranslate"><span class="pre">constant_circuit</span></code> to prepare <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code>. Since we cannot measure <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Z</span></code> at the same time the <code class="docutils literal notranslate"><span class="pre">circuits</span></code> list will include one quantum circuit that does not apply any additional gate and one circuit that rotates the qubit basis into the <code class="docutils literal notranslate"><span class="pre">X</span></code>-basis so that the expecation value <code class="docutils literal notranslate"><span class="pre">&lt;X&gt;</span></code> is equivalent to the measurement of <code class="docutils literal notranslate"><span class="pre">&lt;Z&gt;</span></code> in the new basis.
This kind of measurement is referred to as a PauliZProduct measurement because each qubit is rotated in the correct basis for the readout.
For the post-processing the PauliZProduct measurement needs two more inputs: Which qubits to combine into expectation values and which weight to use for each result.</p>
<p>In general one can measure the expectation values of the products of local Z operators, e.g. <code class="docutils literal notranslate"><span class="pre">&lt;Z0&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;Z1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;Z0*Z1&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;Z0*Z3&gt;</span></code>, ...
The PauliZProductInput needs to define all of these products that are measured. Here we will measure two products <code class="docutils literal notranslate"><span class="pre">&lt;Z0&gt;</span></code> after a rotation in the X basis and <code class="docutils literal notranslate"><span class="pre">&lt;Z0&gt;</span></code> without an additional rotation.
The PauliZProductInput also defines the weights of the products in the final result. Here 0.1 for the first product and 0.2 for the second.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">qoqo.measurements</span> <span class="kn">import</span> <span class="n">PauliZProduct</span><span class="p">,</span> <span class="n">PauliZProductInput</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">QuantumProgram</span>
<span class="c1"># initialize |psi&gt;</span>
<span class="n">init_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">init_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># Z-basis measurement circuit with 1000 shots</span>
<span class="n">z_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="c1"># X-basis measurement circuit with 1000 shots</span>
<span class="n">x_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Changing to the X basis with a Hadamard gate</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Preparing the measurement input for one qubit</span>
<span class="c1"># The PauliZProductInput starts with just the number of qubtis</span>
<span class="c1"># and if to use a flipped measurements set.</span>
<span class="n">measurement_input</span> <span class="o">=</span> <span class="n">PauliZProductInput</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="c1"># Next, pauli products are added to the PauliZProductInput</span>
<span class="c1"># Read out product of Z on site 0 for register ro_z (no basis change)</span>
<span class="n">z_basis_index</span> <span class="o">=</span> <span class="n">measurement_input</span><span class="o">.</span><span class="n">add_pauliz_product</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,])</span>
<span class="c1"># Read out product of Z on site 0 for register ro_x</span>
<span class="c1"># (after basis change effectively a &lt;X&gt; measurement)</span>
<span class="n">x_basis_index</span> <span class="o">=</span> <span class="n">measurement_input</span><span class="o">.</span><span class="n">add_pauliz_product</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,])</span>

<span class="c1"># Last, instructions how to combine the single expectation values</span>
<span class="c1"># into the total result are provided.</span>
<span class="c1"># Add a result (the expectation value of H) that is a combination of</span>
<span class="c1"># the PauliProduct expectation values.</span>
<span class="n">measurement_input</span><span class="o">.</span><span class="n">add_linear_exp_val</span><span class="p">(</span><span class="s2">&quot;&lt;H&gt;&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">x_basis_index</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">z_basis_index</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">})</span>

<span class="n">measurement</span> <span class="o">=</span> <span class="n">PauliZProduct</span><span class="p">(</span>
   <span class="n">constant_circuit</span><span class="o">=</span><span class="n">init_circuit</span><span class="p">,</span>
   <span class="n">circuits</span><span class="o">=</span><span class="p">[</span><span class="n">z_circuit</span><span class="p">,</span> <span class="n">x_circuit</span><span class="p">],</span>
   <span class="nb">input</span><span class="o">=</span><span class="n">measurement_input</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For an overview of other available readouts and measurements please see the <a class="reference external" href="https://github.com/HQSquantumsimulations/qoqo">qoqo</a> documentation.</p>
<p>The qoqo QuantumProgram combines a measurement with a list of free parameters that are not set at compile time but can be dynamically set whenever the QuantumProgram is run.
To demonstrate we modify the example from above to use a state <code class="docutils literal notranslate"><span class="pre">|psi&gt;</span></code> with a free angle between <code class="docutils literal notranslate"><span class="pre">|0&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">|1&gt;</span></code>. Such a state can be prepared by a <code class="docutils literal notranslate"><span class="pre">RotateX</span></code> quantum operation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">qoqo.measurements</span> <span class="kn">import</span> <span class="n">PauliZProduct</span><span class="p">,</span> <span class="n">PauliZProductInput</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">QuantumProgram</span>
<span class="c1"># initialize |psi&gt;</span>
<span class="n">init_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># Apply a RotateY gate with a symbolic angle</span>
<span class="c1"># To execute the circuit this symbolic parameter needs to be replaced</span>
<span class="c1"># by a real number with the help of a QuantumProgram</span>
<span class="n">init_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RotateY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;angle&quot;</span><span class="p">)</span>
<span class="c1"># Z-basis measurement circuit with 1000 shots</span>
<span class="n">z_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="c1"># X-basis measurement circuit with 1000 shots</span>
<span class="n">x_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Changing to the X basis with a Hadamard gate</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="c1"># Preparing the measurement input for one qubit</span>
<span class="n">measurement_input</span> <span class="o">=</span> <span class="n">PauliZProductInput</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
<span class="c1"># Read out product of Z on site 0 for register ro_z (no basis change)</span>
<span class="n">z_basis_index</span> <span class="o">=</span> <span class="n">measurement_input</span><span class="o">.</span><span class="n">add_pauliz_product</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,])</span>
<span class="c1"># Read out product of Z on site 0 for register ro_x</span>
<span class="c1"># (after basis change effectively a &lt;X&gt; measurement)</span>
<span class="n">x_basis_index</span> <span class="o">=</span> <span class="n">measurement_input</span><span class="o">.</span><span class="n">add_pauliz_product</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,])</span>

<span class="c1"># Add a result (the expectation value of H) that is a combination of</span>
<span class="c1"># the PauliProduct expectation values</span>
<span class="n">measurement_input</span><span class="o">.</span><span class="n">add_linear_exp_val</span><span class="p">(</span><span class="s2">&quot;&lt;H&gt;&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">x_basis_index</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">z_basis_index</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">})</span>

<span class="n">measurement</span> <span class="o">=</span> <span class="n">PauliZProduct</span><span class="p">(</span>
   <span class="n">constant_circuit</span><span class="o">=</span><span class="n">init_circuit</span><span class="p">,</span>
   <span class="n">circuits</span><span class="o">=</span><span class="p">[</span><span class="n">z_circuit</span><span class="p">,</span> <span class="n">x_circuit</span><span class="p">],</span>
   <span class="nb">input</span><span class="o">=</span><span class="n">measurement_input</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># A quantum program is created from the measurement and &quot;angle&quot; is registered as</span>
<span class="c1"># a free input parameter.</span>
<span class="c1"># The QuantumProgram now has one free parameter that needs to set when executing it.</span>
<span class="c1"># The symbolic value angle in the circuits will be replaced by that free parameter</span>
<span class="c1"># during execution.</span>
<span class="n">program</span> <span class="o">=</span> <span class="n">QuantumProgram</span><span class="p">(</span>
   <span class="n">measurement</span><span class="o">=</span><span class="n">measurement</span><span class="p">,</span>
   <span class="n">input_parameter_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>For details on how to execute QuantumPrograms see <a class="reference internal" href="execution.html"><span class="doc">Executing quantum programs</span></a>.</p>
<section id="a-quantumprogram-returning-unprocessed-measurements">
<h3>A QuantumProgram returning unprocessed measurements<a class="headerlink" href="#a-quantumprogram-returning-unprocessed-measurements" title="Permalink to this headline"></a></h3>
<p>There also exist many use cases where end users want to receive the full measurement output without post-processing.
For example when working with external tools that expect full  measurement records or when implementing custom post-processing.
For these use cases the <code class="docutils literal notranslate"><span class="pre">ClassicalRegister</span></code> measurement can be used to create three dictionaries, one for all registers with bit values, one forall registers with float values and one for all registers with complex values.
Note that this measurement does not need a separate measurement input as no post-processing takes place</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">Circuit</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">operations</span> <span class="k">as</span> <span class="n">ops</span>
<span class="kn">from</span> <span class="nn">qoqo.measurements</span> <span class="kn">import</span> <span class="n">ClassicalRegister</span>
<span class="kn">from</span> <span class="nn">qoqo</span> <span class="kn">import</span> <span class="n">QuantumProgram</span>
<span class="c1"># initialize |psi&gt;</span>
<span class="n">init_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="c1"># Apply a RotateY gate with a symbolic angle</span>
<span class="c1"># To execute the circuit this symbolic parameter needs to be replaced</span>
<span class="c1"># with a real number with the help of a QuantumProgram</span>
<span class="n">init_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">RotateY</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;angle&quot;</span><span class="p">)</span>
<span class="c1"># Z-basis measurement circuit with 1000 shots</span>
<span class="n">z_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">z_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_z&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="c1"># X-basis measurement circuit with 1000 shots</span>
<span class="n">x_circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">DefinitionBit</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">is_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Changing to the X basis with a Hadamard gate</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">Hadamard</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">x_circuit</span> <span class="o">+=</span> <span class="n">ops</span><span class="o">.</span><span class="n">PragmaRepeatedMeasurement</span><span class="p">(</span><span class="s2">&quot;ro_x&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

<span class="n">measurement</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">constant_circuit</span><span class="o">=</span><span class="n">init_circuit</span><span class="p">,</span> <span class="n">circuits</span><span class="o">=</span><span class="p">[</span><span class="n">z_circuit</span><span class="p">,</span> <span class="n">x_circuit</span><span class="p">])</span>

<span class="c1"># A quantum program is created from the measurement and &quot;angle&quot; is registered as a free input parameter</span>
<span class="c1"># The QuantumProgram now has one free parameter that needs to set when executing it.</span>
<span class="c1"># The symbolic value angle in the circuits will be replaced by that free parameter during execution.</span>
<span class="n">program</span> <span class="o">=</span> <span class="n">QuantumProgram</span><span class="p">(</span><span class="n">measurement</span><span class="o">=</span><span class="n">measurement</span><span class="p">,</span> <span class="n">input_parameter_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">])</span>
</pre></div>
</div>
<p>For details on how to execute QuantumPrograms see <a class="reference internal" href="execution.html"><span class="doc">Executing quantum programs</span></a>.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="execution.html" class="btn btn-neutral float-right" title="Executing quantum programs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, HQS Quantum Simulations GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>